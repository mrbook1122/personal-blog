# 2020-08-12

## 1. Java内存模型

不同的CPU具有不同的内存模型，有些CPU是强内存模型，所有的处理器在任一时间对任意内存区域访问都会得到相同的值，有些CPU是弱内存模型，需要特殊的指令，比如内存屏障来刷新本地缓存，来保证其他处理器对数据的修改对于本CPU的可见性。Java内存模型描述了在多线程代码中哪些行为是合法的，如何处理内存，它描述了在计算机中如何储存和获取变量的低层次细节，以保证用volite和synchronized在不同硬件平台具有的一致性。

## 2. 多态

Java通过动态绑定来实现多态。

## 3. Java内存回收概述

程序计数器，虚拟机栈，本地方法栈3个区域随着线程的生命周期，并且每个栈帧需要多少的内存基本在类结构确定下来时便是已知的，因此这几个区域的回收具有确定性。

而Java堆和方法区则具有显著的不确定性，一个接口的多个实现类所需的内存不一样，一个方法所执行的不同条件分支所需要的内存也不一样。

## 4. 判断对象是否死亡

有两种方法，1是引用计数法 2.可达性分析法

## 5. GCRoots对象

1. 虚拟机栈中引用的对象，比如参数，局部变量，临时变量

2. 方法区中类静态属性引用的对象

3. 方法去中常量引用的对象

4. 被同步锁持有的对象

5. Java虚拟记内部的引用，比如Class对象，一些常驻的异常对象，比如NullPointerException

## 6. 引用分类

JDK1.2之后引用分为 强引用、软引用、弱引用、虚引用(强度一次递减)。

软引用描述一些可能还有用，但是非必须的对象，这些对象只有在系统要发生内存溢出之前被回收，如果回收这些对象之后依然内存不足，才会发生内存溢出异常。

弱引用也是描述非必须的对象，这些对象会在下次垃圾回收的时候被回收。

无法通过虚引用来获取一个对象的实例，为一个对象设置虚引用的目的是为了这个对象在被垃圾回收的时候得到一个通知。
